{"rule":"WHITESPACE_RULE","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q → \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, starting when \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q fails \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q → \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q elements of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q where \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is false \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q → \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sub-iterators grouped by value of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q  \n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q elements from seqstart:stop:step islice('ABCDEFG', 2, None) --> C D E F G\n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q (p0, p1), (p1, p2) pairwise('ABCDEFG') --> AB BC CD DE EF FG\n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q func(*seq0), func(*seq1), … starmap(pow, (2,5), (3,2), (10,3)) --> 32 9 1000\n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q seq0, seq1, until pred fails takewhile(lambda x: x<5, 1,4,6,4,1) --> 1 4\n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q it1, it2, … itn splits one iterator into n  \n\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q (p0, q0), (p1, q1), … zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-\\E$"}
